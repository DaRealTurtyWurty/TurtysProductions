<!DOCTYPE html>
<html lang="en">
    <head>
        <title>1.12.2 Item.java</title>
        <link rel="stylesheet" href="../../../stylesheets/dictionaryStyle.css">
    </head>
    <body>
        <nav>
            <ul>
                <li class="active"><a href="../../moddingdictionary.html" class="aactive">Modding Version Dictionaries</a></li>
                <li class="active"><a href="../../minecraftmods.html" class="inactive">My Minecraft Mods</a></li>
                <li class="active"><a href="../../../index.html" class="inactive">Home</a></li>
            </ul>
            <h1>Turty's Productions</h1>
        </nav>
        <form>
            <div>
                <button onclick="search()" id="searchButton" type='button'>Search</button>
                <script>
                    function search() {
                        var text = document.getElementById("name").value;
                        var elements = Array.from(document.getElementsByClassName("items"));
                        var correctCriteriaElements = [];
                        elements.forEach(element => {
                            if((text.split("(")[0] != null && text.split("(")[0] != "undefined" && text.split("(")[0] != "") && (element.textContent.includes(text.split("(")[0]))) {
                                console.log(element.textContent.split("(")[0])
                                correctCriteriaElements.push(element);
                            }
                        });
                        correctCriteriaElements[0].scrollIntoView();
                    }
                </script>

                <input type="search" id="name" name="name" required minlength="0" maxlength="30" size="30" placeholder="Search for methodName">
            </div>
        </form>
        <section>
                <p class="headingPara">Item.java methods and variables</p>
                <h6>
                    <ul>
                        <br><br><h6><strong>addInformation</strong> is a <strong>public void</strong> so it does not return anything, 
                            it is used for adding a tooltip to the item(a short description). 
                            <strong>stack</strong> is the itemstack to add the tooltip to. 
                            <strong>worldIn</strong> is the world that the stack is in. 
                            <strong>tooltip</strong> allows you to then add a tooltip 
                            using <strong>tooltip.add()</strong>. Finally 
                            <strong>flagIn</strong> can be used to declare 
                            whether it is an <code><strong>ADVANCED</strong></code> 
                            tooltip or a <strong><code>NORMAL</strong></code> tooltip.</h6>
                        <li class="items"><code>addInformation(ItemStackStack stack, World worldIn, List&lt;String&gt; tooltip, ITooltipFlag flagIn)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn)
{
    tooltip.add("this is a tooltip and will show up when you hover over the item in a container");
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canApplyAtEnchantingTable</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the enchantment can be applied to this item. <strong>stack </strong>
                            is the itemstack to be enchanted. <strong>enchantment</strong> is the enchantment to be 
                            applied. This method checks whether an item can be enchanted with a certain 
                            enchantment. This applies specifically to enchanting an item in the 
                            enchanting table and is called when retrieving the list of possible 
                            enchantments for an item.</h6>
                        <li class="items"><code>canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) 
{
    if(!enchantment.isCompatibleWith(Enchantments.EFFICIENCY))
    {
        return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canDestroyBlockInCreative</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the given player can destroy 
                            the specified block in creative mode with this item. 
                            <strong>world</strong> is the world that the block is in. 
                            <strong>pos</strong> is the position of the block in the world. 
                            <strong>stack</strong> is the itemstack that can/cannot break the block. 
                            <strong>player</strong> is the player that is trying to break the block.</h6>
                        <li class="items"><code>canDestroyBlockInCreative(World world, BlockPos pos, ItemStack stack, EntityPlayer player)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canDestroyBlockInCreative(World world, BlockPos pos, ItemStack stack, EntityPlayer player) 
{
    if(!player.canBreatheUnderwater() && world.getBlockState(pos).getBlock() == Blocks.BED)
    {
        return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canDisableShield</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the item can disable a shield. 
                            <strong>stack</strong> is the itemstack. 
                            <strong>shield</strong> is the stack of the shield in question. 
                            <strong>entity</strong> is the EntityLivingBase that is holding the shield. 
                            <strong>attacker</strong> is the EntityLivingBase that is holding the itemstack.</h6>
                        <li class="items"><code>canDisableShield(ItemStack stack, ItemStack shield, EntityLivingBase entity, EntityLivingBase attacker)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canDisableShield(ItemStack stack, ItemStack shield, EntityLivingBase entity, EntityLivingBase attacker) 
{
    if(entity.isChild())
    {
         return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canHarvestBlock</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the player can harvest a block with that itemstack. 
                            <strong>blockIn</strong> is the state of the block that is in question.</h6>
                        <li class="items"><code>canHarvestBlock(IBlockState blockIn)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canHarvestBlock(IBlockState blockIn) 
{
    if(blockIn.causesSuffocation())
    {
        return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canHarvestBlock</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the player can harvest a block with that itemstack. 
                            <strong>blockIn</strong> is the state of the block that is in question. 
                            <strong>stack</strong> is the itemstack. This is the ItemStack sensitive
                            version.
                        </h6>
                        <li class="items"><code>canHarvestBlock(IBlockState state, ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canHarvestBlock(IBlockState state, ItemStack stack) 
{
    if(state.causesSuffocation() && stack.canEditBlocks())
    {
        return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>canItemEditBlocks</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if this item ignores other restrictions 
                            on how a player can modify the world. 
                            Forces <strong>EntityPlayer#canPlayerEdit</strong> to return true.</h6>
                        <li class="items"><code>canItemEditBlocks()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canItemEditBlocks()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>createEntity</strong> 
                            is a <strong>public Entity</strong>, so should return a new entity 
                            to replace the dropped item. Returning <strong>null </strong>
                            here will not kill the <strong>EntityItem</strong> and will leave 
                            it to function normally. Called when the item 
                            is placed in a world. <strong>world</strong> is the world object. 
                            <strong>location</strong> is the <strong>EntityItem</strong> object, and is useful 
                            for getting the position of the entity. 
                            <strong>itemStack</strong> is the current itemstack.</h6>
                        <li class="items"><code>createEntity(World world, Entity location, ItemStack itemstack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Entity createEnity(World world, Entity location, ItemStack itemstack)
{
    if(location.getPosition().getY() > 100)
    {
        return new EntityCow(world);
    }
    return null;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>doesSneakBypassUse</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if this item, when held, allows 
                            sneak-clicks to pass through to the underlying block. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>world</strong> is the world. 
                            <strong>pos</strong> is the block position in the world. 
                            <strong>player</strong> is the player that is wielding the item.</h6>
                        <li class="items"><code>doesSneakBypassUse(ItemStack stack, IBlockAccess world, BlockPos pos, EntityPlayer player)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override    
public boolean doesSneakBypassUse(ItemStack stack, IBlockAccess world, BlockPos pos, EntityPlayer player)
{
    if(!world.getBlockState(pos).isFullBlock())
    {
        return true;
    }
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getAnimationParameters</strong> 
                            is a bit complex and is a <strong>public ImmutableMap&lt;String, ITimeValue&gt;</strong>. 
                            All 3 parameters are <strong>final</strong> as <strong>ImmutableMap</strong>s can only have 
                            contents that will never change. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>world</strong> is the world object. 
                            <strong>entity</strong> is the <strong>EntityLivingBase</strong> that this animation is affecting. 
                            It is used to retrieve parameters to an item animation 
                            mechanism which is known as animation state machine or 
                            ASM(not to be confused with the Advanced System Manager). 
                            You can read about this in the Forge Docs 
                            <a href="https://mcforge.readthedocs.io/en/latest/animation/intro/" class="hyperlink"><strong>here</strong></a> as it does 
                            get very complex! It is mostly unused in forge, so it is 
                            unlikely for the common user to ever need it, but it 
                            is there just in case.</h6>
                        <li class="items"><code>getAnimationParameters(ItemStack stack, World world, EntityLivingBase entity)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public ImmutableMap&lt;String, ITimeValue&gt; getAnimationParameters(ItemStack stack, World world, EntityLivingBase entity)
{
    return stack.getItem().getAnimationParameters(stack, world, entity);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getArmorModel</strong> 
                            is a <strong>public String</strong>, and is called by <strong>RenderBiped</strong> and 
                            <strong>RenderPlayer</strong> to determine the armor texture that 
                            should be use for the currently equipped item. 
                            This will only be called on instances of <strong>ItemArmor</strong>. 
                            It returns the path of texture to bind, or return 
                            <strong>null</strong> to use the default path. 
                            <strong>stack</strong> is the itemstack for the equipped armor. 
                            <strong>entity</strong> is the entity that is wearing the armor. 
                            <strong>slot</strong> is the <strong>EntityEquipmentSlot</strong> that the armor is in. 
                            <strong>type</strong> is the subtype; can be <strong>null</strong> or <strong>"overlay"</strong>.</h6>
                        <li class="items"><code>getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, ModelBiped _default)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public ModelBiped getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, ModelBiped _default)
{
    return new ModelBiped();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getContainerItem</strong> 
                            is a <strong>public Item</strong> and gets 
                            the item that is a container item, this means 
                            that it has a crafting result for example. 
                            This is the non-itemstack sensitive version. 
                            This method is nullable which means that 
                            it can return <strong>null</strong>, but 
                            otherwise it returns the resulting Item.</h6>
                        <li class="items"><code>getContainerItem()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Item getContainerItem()
{
    return Items.APPLE;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getContainerItem</strong> 
                            is the itemstack sensitive version 
                            of <strong> getContainerItem()</strong> and is a <strong>public ItemStack</strong>, 
                            this means that it returns the resulting itemstack. 
                            <strong>itemStack</strong> is the current itemstack.</h6>
                        <li class="items"><code>getContainerItem(ItemStack itemStack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Item getContainerItem(ItemStack itemStack)
{
    return new ItemStack(Item.getItemFromBlock(Blocks.ANVIL));
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getCreativeTab</strong> 
                            is a <strong>public CreativeTabs</strong> and 
                            gets the <strong>CreativeTabs</strong> that 
                            this item is displayed on. It returns the tab 
                            for it to be displayed on.</h6>
                        <li class="items"><code>getCreativeTab()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public CreativeTabs getCreativeTab()
{
    return CreativeTabs.BREWING;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getCreativeTabs</strong> 
                            is a <strong>public CreativeTabs[]</strong>, so it 
                            returns a list of all tabs that this item could 
                            possibly be on. The method gets a list of tabs 
                            that items belonging to this class can display on, 
                            combined properly with <strong>getSubItems()</strong> allows for a 
                            single item to span many sub-items across many tabs.</h6>
                        <li class="items"><code>getCreativeTabs()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public CreativeTabs getCreativeTab()
{
    return CreativeTabs.BREWING;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getCreatorModId</strong> 
                            is a <strong>public String</strong>, so it returns the Mod ID 
                            for the itemstack, or null when there is no specially associated 
                            mod and <strong>getRegistryName()</strong> would 
                            return <strong>null</strong>. It is called to 
                            get the Mod ID of the mod that *created* the itemstack, 
                            instead of the real Mod ID that *registered* it. 
                            For example the Forge Universal Bucket creates a 
                            sub-item for each modded fluid, and it returns 
                            the modded fluid's Mod ID here. Mods that register 
                            sub-items for other mods can override this. 
                            Informational mods can call it to show the 
                            mod that created the item. 
                            <strong>itemStack</strong> is the itemstack to check.</h6>
                        <li class="items"><code>getCreatorModId(ItemStack itemStack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public String getCreatorModId(ItemStack itemStack)
{
    return this.getRegistryName().getResourceDomain();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getDamage</strong> 
                            is a <strong>public int</strong> and returns 
                            the <strong>itemDamage</strong> represented by this 
                            ItemStack(the damage value), the 'damage' 
                            is more commonly known as durability. 
                            This defaults to the <strong>itemDamage</strong> field on <strong>ItemStack</strong>, 
                            but can be overridden here for other sources 
                            such as NBT. <strong>stack</strong> is the itemstack that is getting damaged.</h6>
                        <li class="items"><code>getDamage(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getDamage(ItemStack stack)
{
    return 5000;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getDefaultInstance</strong> 
                            is a <strong> public ItemStack</strong> and returns the 
                            itemstack to create a default instance of. For example 
                            this would affect if you wanted to do something 
                            like <strong>new ItemStack(Items.FLINT)</strong>.</h6>
                        <li class="items"><code>getDefaultInstance()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public ItemStack getDefaultInstance()
{
    return new ItemStack(Items.ARROW);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getDestroySpeed</strong> 
                            is a <strong>public float</strong> and returns 
                            a <strong>float</strong> for the speed that this 
                            item destroys a block. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>state</strong> is the <strong>IBlockState</strong> of the 
                            block that you are breaking.</h6>
                        <li class="items"><code>getDestroySpeed(ItemStack stack, IBlockState state)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public float getDestroySpeed(ItemStack stack, IBlockState state)
{
    return 1.2f;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getDurabilityForDisplay</strong> 
                            is a <strong>public double</strong> and returns the 
                            percentage of durability to display - 
                            <strong>0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged / empty bar)</strong>. 
                            It queries the percentage of the 'Durability' bar that should be drawn. 
                            <strong>stack</strong> is the current itemstack.</h6>
                        <li class="items"><code>getDurabilityForDisplay(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override#
public double getDurabilityForDisplay(ItemStack stack)
{
    return 0.0f;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getEntityLifespan</strong> 
                            retrieves the normal 'lifespan' of this item when it 
                            is dropped on the ground as a <strong>EntityItem</strong>. 
                            This is in ticks, standard result is 6000, or 5 mins. 
                            It is a <strong>public int</strong> and returns the 
                            normal lifespan in ticks(<strong>20 ticks = 1 second</strong>). 
                            <strong>itemStack</strong> is the current itemstack. 
                            <strong>world</strong> is the world that the entity is in.</h6>
                        <li class="items"><code>getEntityLifespan(ItemStack itemStack, World world)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getEntityLifespan(ItemStack itemStack, World world)
{
    return 120000; //10 minutes
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getEquipmentSlot</strong> 
                            is a <strong>public EntityEquipmentSlot</strong> and 
                            returns the armor slot of the <strong>ItemStack</strong>, or <strong>null</strong> to 
                            let the default vanilla logic as per <strong>EntityLiving.getSlotForItemStack(stack)</strong> decide. 
                            Override this to set a non-default armor slot for an ItemStack, but 
                            do not use this to get the armor slot of said stack; for that, use 
                            <strong>net.minecraft.entity.EntityLiving.getSlotForItemStack(ItemStack)</strong>. 
                            <strong>stack</strong> is the item stack.</h6>
                        <li class="items"><code>getEquipmentSlot(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public EntityEquipmentSlot getEquipmentSlot(ItemStack stack)
{
    return EntityEquipmentSlot.CHEST;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getFontRenderer</strong> 
                            is a <strong>public FontRenderer</strong> and returns 
                            the font renderer used to render tooltips and overlays 
                            for this item. Returning <strong>null</strong> will use the 
                            standard font renderer. 
                            <strong>stack</strong> The current item stack.</h6>
                        <li class="items"><code>getFontRenderer(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public FontRenderer getFontRenderer(ItemStack stack)
{
    return super.getFontRenderer(stack);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getHarvestLevel</strong> 
                            is a <strong>public int</strong> and returns the 
                            harvest level, or -1 if not the specified tool type. 
                            It queries the harvest level of this item stack for the specified tool class. 
                            <strong>stack</strong> is this itemstack instance. 
                            <strong>toolClass</strong> is the string class name for a tool.</h6>
                        <li class="items"><code>getHarvestLevel(ItemStack stack, String toolClass, EntityPlayer player, IBlockState blockState)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getHarvestLevel(ItemStack stack, String toolClass, EntityPlayer player, IBlockState blockState)
{
    return 1;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getHasSubtypes</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong>
                            if the item has metadata such as dye having 16 variants. 
                            This should not be used as it is totally removed in version 1.13+, however 
                            it will still work. It is known as bad practice to utilize it though.</h6>
                        <li class="items"><code>getHasSubtypes()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean getHasSubtypes()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getHighlightTip</strong> 
                            is a <strong>public String</strong> and allows the item one 
                            last chance to modify its name used for the tool highlight 
                            useful for adding something extra that can't be removed by a 
                            user in the displayed name, such as a mode of operation. 
                            <strong>item</strong> is the item stack for the item. 
                            <strong>displayName</strong> is the name that will be displayed 
                            unless it is changed in this method.</h6>
                        <li class="items"><code>getHighlightTip(ItemStack item, String displayName)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public String getHighlightTip(ItemStack item, String displayName)
{
    return "A highlight tip";
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getHorseArmorTexture</strong> 
                            is a <strong>public String</strong> and therefore returns 
                            the name of the texture which is is wanted on the armor. 
                            It allows you to change the texture on the horse. 
                            <strong>wearer</strong> is the <strong>EntityLiving</strong> that has the armor equipped. 
                            <strong>stack</strong> is the current ItemStack.</h6>
                        <li class="items"><code>getHorseArmorTexture(EntityLiving wearer, ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public String getHorseArmorTexture(EntityLiving wearer, ItemStack stack)
{
    return "minecraft:textures/entity/horse/armor/horse_armor_diamond";
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getHorseArmorType</strong> 
                            is a <strong>public HorseArmorType</strong> and therefore returns 
                            an enum constant of type <strong>HorseArmorType</strong>. 
                            You return <strong>HorseArmorType.NONE</strong> if this item is 
                            not horse armor. The returned enum constant will be used to 
                            determine the armor value and texture of this item when equipped. 
                            <strong>stack</strong> is the armor stack.</h6>
                        <li class="items"><code>getHorseArmorType(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public HorseArmorType getHorseArmorType(ItemStack stack)
{
    return HorseArmorType.GOLD;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getIsRepairable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> 
                            if this itemstack is repairable in an anvil. 
                            <strong>toRepair</strong> is the itemstack that is being repaired. 
                            <strong>repair</strong> is the itemstack being used to 
                            perform the repair(such as iron ingot for iron armor).</h6>
                        <li class="items"><code>getIsRepairable(ItemStack toRepair, ItemStack repair)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean getIsRepairable(ItemStack toRepair, ItemStack repair)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemAttributeModifiers</strong> 
                            is a <strong>public Multimap&lt;String, AttributeModifier&gt;</strong> and 
                            gets a map of item attribute modifiers, used by <strong>ItemSword</strong> to 
                            increase hit damage. <strong>equipmentSlot</strong> is the <strong>EntityEquipmentSlot</strong> that 
                            the ItemStack is in. This method is deprecated and instead you should use the 
                            ItemStack sensitive version <strong>getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot, ItemStack stack)</strong>.</h6>
                        <li class="items"><code>getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Multimap&lt;String, AttributeModifier&gt; getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot)
{
    Multimap&lt;String, AttributeModifier&gt; multimap = super.getItemAttributeModifiers(equipmentSlot);
    if(equipmentSlot == EntityEquipmentSlot.MAINHAND)
    {
        multimap.put(SharedMonsterAttributes.ATTACK_DAMAGE.getName(), new AttributeModifier(ATTACK_DAMAGE_MODIFIER, "Weapon modifier", 0.5D, 0));
        multimap.put(SharedMonsterAttributes.ATTACK_SPEED.getName(), new AttributeModifier(ATTACK_SPEED_MODIFIER, "Weapon modifier", 3.0D, 0))
    }
    return multimap;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemBurnTime</strong> 
                            is a <strong>public int</strong> and returns the fuel 
                            burn time for this itemStack in a furnace. Return <strong>0</strong> to 
                            make it not act as a fuel. Return <strong>-1</strong> to let the 
                            default vanilla logic decide. 
                            <strong>itemStack</strong> is the item stack which is being queried about.</h6>
                        <li class="items"><code>getItemBurnTime(ItemStack itemStack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getItemBurnTime(ItemStack itemStack)
{
    return 6000; //5 minutes
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemEnchantability</strong> 
                            is a <strong>public int</strong> and returns the 
                            <strong>enchantability factor</strong> of the item, most of 
                            the time is based on material. </h6>
                        <li class="items"><code>getItemEnchantability()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getItemEnchantability()
{
    return 10;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemEnchantability</strong> 
                            is a <strong>public int</strong> and is the itemstack 
                            sensitive version of <strong>getItemEnchantability()</strong>. 
                            It returns the item enchantability value of the ItemStack. 
                            <strong>stack</strong> is the current ItemStack.</h6>
                        <li class="items"><code>getItemEnchantability(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getItemEnchantability(ItemStack stack)
{
    return 20;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemStackDisplayName</strong> 
                            is a <strong>public String</strong> and returns the 
                            display name for this ItemStack. 
                            <strong>stack</strong> is the itemstack to have it's name changed.</h6>
                        <li class="items"><code>getItemStackDisplayName(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public String getItemStackDisplayName(ItemStack stack) 
{
    return stack.getDisplayName();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemStackLimit</strong> 
                            is the maximum number of items that the ItemStack can hold. 
                            It is a <strong>public int</strong> and therefore returns 
                            an integer value of the max number of items in the stack. 
                            This method is deprecated and you should use the ItemStack sensitive version. 
                            Even though it is named <strong>get</strong>, it is actually 
                            a <strong>set</strong> method.</h6>
                        <li class="items"><code>getItemStackLimit()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getItemStackLimit()
{
    return 16;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getItemUseAction</strong> 
                            is a <strong>public EnumAction</strong> and returns the action 
                            that specifies what animation to play when the items is being used. 
                            <strong>stack</strong> is the item stack to apply the action to.</h6>
                        <li class="items"><code>getItemUseAction(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public EnumAction getItemUseAction(ItemStack stack)
{
    return EnumAction.DRINK;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getMaxDamage</strong> 
                            is a <strong>public int</strong> and returns the 
                            maximum damage(more commonly known as durability) that the item 
                            can take as an integer. This method is deprecated and 
                            you should use the ItemStack sensitive version. </h6>
                        <li class="items"><code>getMaxDamage()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getMaxDamage()
{
    return 200;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getMaxDamage</strong> 
                            is a <strong>public int</strong> and returns 
                            the <strong>maxDamage</strong>(maxDurability) for this ItemStack. 
                            Defaults to the maxDamage field in this item, but can be overridden 
                            here for other sources such as NBT.  
                            <strong>stack</strong> is the item stack that can be damaged.</h6>
                        <li class="items"><code>getMaxDamage(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getMaxDamage(ItemStack stack)
{
    return 200;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getMaxItemUseDuration</strong> 
                            is used for getting the max number of times the item can be 
                            used before consumed.  It is a <strong>public int</strong> and 
                            therefore requires an integer to be returned. 
                            <strong>stack</strong> is the itemstack to be used.</h6>
                        <li class="items"><code>getMaxItemUseDuration(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getMaxItemUseDuration(ItemStack stack)
{
    return 500;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getMetadata</strong> 
                            converts the given ItemStack damage value into a metadata 
                            value to be placed in the world when this Item is placed as 
                            a Block (mostly used with <strong>ItemBlocks</strong>). 
                            It is a <strong>public int</strong> as it returns an integer 
                            value. <strong>damage</strong> is an integer value for the 
                            current damage of the item.</h6>
                        <li class="items"><code>getMetadata(int damage)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getMetadata(int damage)
{
    return 2;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getMetadata</strong> 
                            used to be 'display damage', but its really just 'aux' data 
                            in the ItemStack, usually shares the same variable as damage. 
                            <strong>stack</strong> is the ItemStack to get the metadata from. 
                            It is a <strong>public int</strong> as it returns an integer 
                            value of the damage.</h6>
                        <li class="items"><code>getMetadata(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getMetadata(ItemStack stack)
{
    return 2;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getNBTShareTag</strong> 
                            can be overridden to change the NBT data being sent to the client. 
                            You should <strong>ONLY</strong> override this when you have no other choice, 
                            as this might change behavior client side! Note that this will sometimes be 
                            applied multiple times, the following MUST be supported: 
                            <strong>Item item = stack.getItem();</strong> 
                            <strong>NBTTagCompound nbtShare1 = item.getNBTShareTag(stack);</strong> 
                            <strong>stack.setTagCompound(nbtShare1);</strong> 
                            <strong>NBTTagCompound nbtShare2 = item.getNBTShareTag(stack);</strong> assert 
                            <strong>nbtShare1.equals(nbtShare2);</strong>. 
                            It is a <strong>public NBTTagCompound</strong> as it returns the NBT tag. 
                            <strong>stack</strong> is the stack to send the NBT tag for.</h6>
                        <li class="items"><code>getNBTShareTag(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public NBTTagCompound getNBTShareTag(ItemStack stack)
{
    Item item = stack.getItem();
    NBTTagCompound nbtShare1 = item.getNBTShareTag(stack); 
    stack.setTagCompound(nbtShare1);
    NBTTagCompound nbtShare2 = item.getNBTShareTag(stack);
    nbtShare1.equals(nbtShare2);
    return nbtShare1;
}</code></pre>
                        <hr>
                        <br><br><h6>Firstly, an <strong>IItemPropertyGetter</strong> is just a function 
                            that extracts a property from an itemstack(sort of like a lens). 
                            This method just retrieves one of these 'lenses' by a <strong>ResourceLocation</strong> identifier. 
                            This gets called to apply a property after the 'state' of the item has changed. 
                            Some examples of this are the clock and bow where they both have different 'states', 
                            so it set different icons depending on an external factor.  
                            <strong>key</strong> is the resource location and is the identifier. 
                            It is a <strong>public IItemPropertyGetter</strong> and must return a 
                            new instance of <strong>IItemPropertyGetter</strong> and have the 
                            <strong>apply</strong> method inside.</h6>
                        <li class="items"><code>getPropertyGetter(ResourceLocation key)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public IItemPropertyGetter getPropertyGetter(ResourceLocation key)
{
    //Clock example:
    return new IItemPropertyGetter() 
    {
        @SideOnly(Side.CLIENT)
        double rotation;
        @SideOnly(Side.CLIENT)
        double rota;
        @SideOnly(Side.CLIENT)
        long lastUpdateTick;
        @SideOnly(Side.CLIENT)
        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn)
        {
            boolean flag = entityIn != null;
            Entity entity = (Entity)(flag ? entityIn : stack.getItemFrame());

            if (worldIn == null && entity != null)
            {
                worldIn = entity.world;
            }

            if (worldIn == null)
            {
                return 0.0F;
            }
            else
            {
                double d0;

                if (worldIn.provider.isSurfaceWorld())
                {
                    d0 = (double)worldIn.getCelestialAngle(1.0F);
                }
                else
                {
                    d0 = Math.random();
                }

                d0 = this.wobble(worldIn, d0);
                return (float)d0;
            }
        }
        @SideOnly(Side.CLIENT)
        private double wobble(World p_185087_1_, double p_185087_2_)
        {
            if (p_185087_1_.getTotalWorldTime() != this.lastUpdateTick)
            {
                this.lastUpdateTick = p_185087_1_.getTotalWorldTime();
                double d0 = p_185087_2_ - this.rotation;
                d0 = MathHelper.positiveModulo(d0 + 0.5D, 1.0D) - 0.5D;
                this.rota += d0 * 0.1D;
                this.rota *= 0.9D;
                this.rotation = MathHelper.positiveModulo(this.rotation + this.rota, 1.0D);
            }
            return this.rotation;
        }
    };    
}</code></pre>
                        <br><br><h6><strong>getRarity</strong> 
                            is a <strong>public EnumRarity</strong> and gets an item rarity 
                            from <strong>EnumRarity</strong>, these rarities change the text 
                            color to suit how rare the item is, such as an Enchanted Golden Apple. 
                            <strong>stack</strong> is the item stack to get the rarity of.</h6>
                        <li class="items"><code>getRarity(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public EnumRarity getRarity(ItemStack stack)
{
    return EnumRarity.EPIC;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getRGBDurabilityForDisplay</strong> 
                            is a <strong>public int</strong> and returns a packed RGB value for 
                            the durability color (0x00RRGGBB). This is used to render the durability 
                            bar in the GUI. This defaults to a value based on the hue 
                            scaled based on <strong>getDurabilityForDisplay</strong>, but can be overridden. 
                            <strong>stack</strong> is the item stack to get the RGB durability display from.</h6>
                        <li class="items"><code>getRGBDurabilityForDisplay(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public int getRGBDurabilityForDisplay(ItemStack stack)
{
    return 0xFFA000; //Orange hexadecimal
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getSmeltingExperience</strong> 
                            determines the base experience for a player when they remove this 
                            item from a furnace slot. This number must be between 0 and 1 for 
                            it to be valid as it is <strong>public float</strong>. 
                            This number will be multiplied by the stack size to get the total experience. 
                            <strong>item</strong> is the item stack that the player is picking up.</h6>
                        <li class="items"><code>getSmeltingExperience(ItemStack item)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public float getSmeltingExperience(ItemStack stack)
{
    return 0.7f;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getShareTag</strong> 
                            is a <strong>public boolean</strong> and if this function 
                            returns <strong>true</strong> (or the item is damageable), the 
                            ItemStack's NBT tag will be sent to the client.</h6>
                        <li class="items"><code>getShareTag()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean getShareTag()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getSubItems</strong> 
                            is a <strong>public void</strong> and therefore you cannot 
                            return anything. However, it returns a list of items with the same ID, but 
                            different meta (e.g. dye returns 16 items). <strong>tab</strong> is the Creative Tab 
                            for these sub-items to be in. <strong>items</strong> is a list of non null 
                            item stacks of the sub-items. This should not be used as it is totally 
                            removed in version 1.13+, however it will still work. 
                            It is known as bad practice to utilize it though.</h6>
                        <li class="items"><code>getSubItems(CreativeTabs tab, NonNullList&lt;ItemStack&gt; items)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public void getSubItems(CreativeTabs tab, NonNullList&lt;ItemStack&gt; items)
{
    items.add(new ItemStack(Items.ACACIA_BOAT));
    items.add(new ItemStack(Item.getItemFromBlock(Blocks.ACACIA_FENCE)));
    for(ItemStack itemStack : items)
    {
        itemStack.attemptDamageItem(5, itemRand, null);
    }
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getToolClasses</strong> 
                            is a <strong>public Set&lt;String&gt;</strong> and returns a list of 
                            string versions of tool classes such as <strong>"pickaxe"</strong>. 
                            <strong>stack</strong> is the item stack to get the tool classes from.</h6>
                        <li class="items"><code>getToolClasses(ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Set&lt;String&gt; getToolClasses(ItemStack stack)
{
    toolClass = "pickaxe";
    return toolClass != null ? com.google.common.collect.ImmutableSet.of(toolClass) : super.getToolClasses(stack);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedName</strong> 
                            is a <strong>public String</strong> and returns the unlocalized name 
                            of this item for it to then be localized in the lang file.</h6>
                        <li class="items"><code>getUnlocalizedName()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public String getUnlocalizedName()
{
    switch(stack.getItemDamage())
    {
	case 0:
	    return this.getUnlocalizedName() + "_white";
	case 1:
	    return this.getUnlocalizedName() + "_orange";
	case 2:
	    return this.getUnlocalizedName() + "_magenta";
	case 3:
	     return this.getUnlocalizedName() + "_light_blue";
	case 4:
	     return this.getUnlocalizedName() + "_yellow";
	case 5:
	     return this.getUnlocalizedName() + "_lime";
	case 6:
	     return this.getUnlocalizedName() + "_pink";
	case 7:
	     return this.getUnlocalizedName() + "_gray";
	case 8:
	     return this.getUnlocalizedName() + "_light_gray";
	case 9:
	     return this.getUnlocalizedName() + "_cyan";
	case 10:
	     return this.getUnlocalizedName() + "_purple";
	case 11:
	     return this.getUnlocalizedName() + "_blue";
	case 12:
	     return this.getUnlocalizedName() + "_brown";
	case 13:
	     return this.getUnlocalizedName() + "_green";
	case 14:
	     return this.getUnlocalizedName() + "_red";
	case 15:
	     return this.getUnlocalizedName() + "_black";
	default:
	     return this.getUnlocalizedName();
    }
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedName</strong> 
                            is a <strong>public String</strong> and returns the unlocalized name 
                            of this item for it to then be localized in the lang file. This version accepts an 
                            <strong>ItemStack</strong> so different stacks can have different names based on their damage or NBT. 
                            <strong>stack</strong> is the item stack to get the unlocalized name of.</h6>
                        <li class="items"><code>getUnlocalizedName(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public String getUnlocalizedName(ItemStack stack)
{
    switch(stack.getItemDamage())
    {
	case 0:
	    return this.getUnlocalizedName() + "_white";
	case 1:
	    return this.getUnlocalizedName() + "_orange";
	case 2:
	    return this.getUnlocalizedName() + "_magenta";
	case 3:
	     return this.getUnlocalizedName() + "_light_blue";
	case 4:
	     return this.getUnlocalizedName() + "_yellow";
	case 5:
	     return this.getUnlocalizedName() + "_lime";
	case 6:
	     return this.getUnlocalizedName() + "_pink";
	case 7:
	     return this.getUnlocalizedName() + "_gray";
	case 8:
	     return this.getUnlocalizedName() + "_light_gray";
	case 9:
	     return this.getUnlocalizedName() + "_cyan";
	case 10:
	     return this.getUnlocalizedName() + "_purple";
	case 11:
	     return this.getUnlocalizedName() + "_blue";
	case 12:
	     return this.getUnlocalizedName() + "_brown";
	case 13:
	     return this.getUnlocalizedName() + "_green";
	case 14:
	     return this.getUnlocalizedName() + "_red";
	case 15:
	     return this.getUnlocalizedName() + "_black";
	default:
	     return this.getUnlocalizedName();
    }
}</code></pre>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedNameInefficiently</strong> 
                            is a <strong>public String</strong> and translates the unlocalized name 
                            of this item, but without the <strong>.name</strong> suffix, so the translation 
                            fails and the unlocalized name itself is returned. 
                            <strong>stack</strong> is the item stack to get the unlocalized name of.</h6>
                        <li class="items"><code>getUnlocalizedNameInefficiently(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public String getUnlocalizedNameInefficiently(ItemStack stack)
{
    return super.getUnlocalizedNameInefficiently(stack) + stack.getItemDamage();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hasContainerItem</strong> 
                            is a <strong>public boolean</strong> and should return <strong>true</strong> 
                            if this <strong>Item</strong> has a container item (a.k.a. crafting result). 
                            An example of this is the cake recipe where it gives you back the bucket from the bucket of milk. 
                            This method is deprecated, so you should use the ItemStack sensitive version.</h6>
                        <li class="items"><code>hasContainerItem()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hasContainerItem()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hasContainerItem</strong> 
                            is the ItemStack sensitive version of <strong>hasContainerItem()</strong> and 
                            returns <strong>true</strong> if this item has a 'container'. 
                            <strong>stack</strong> is the current item stack.</h6>
                        <li class="items"><code>hasContainerItem(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hasContainerItem(ItemStack stack)
{
    return this.hasContainerItem();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hasCustomEntity</strong> 
                            determines if this Item has a special entity for when they are in the world. 
                            This is called when an <strong>EntityItem</strong> is spawned in the world, 
                            if <strong>true</strong> and <strong>Item#createCustomEntity</strong> returns non-null, 
                            the <strong>EntityItem</strong> will be destroyed and the new 
                            Entity will be added to the world. <strong>stack</strong> is the 
                            current item stack. This is a <strong>public boolean</strong>, and therefore 
                            must return either <strong>true</strong> or <strong>false</strong>.</h6>
                        <li class="items"><code>hasCustomEntity(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hasCustomEntity(ItemStack stack)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hasCustomProperties</strong> 
                            is a <strong>public boolean</strong>, and therefore must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            This will return <strong>true</strong> if this item has 
                            an <strong>IItemPropertyGetter</strong> and therefore has different 'states'.</h6>
                        <li class="items"><code>hasCustomProperties()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hasCoustomProperties()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hasEffect</strong> 
                            is a <strong>public boolean</strong>, and therefore must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            It returns <strong>true</strong> if this item has an enchantment glint. 
                            By default, this returns <strong>stack.isItemEnchanted()</strong>, but other 
                            items can override it (for instance, written books always return true). 
                            Note that if you override this method, you generally want to also call the 
                            super version (on Item) to get the glint for enchanted items. 
                            Of course, that is unnecessary if the overwritten version always returns true. 
                            <strong>stack</strong> is the item stack to apply the enchantment glint to.</h6>
                        <li class="items"><code>hasEffect(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hasEffect(ItemStack stack)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>hitEntity</strong> 
                            - Current implementations of this method in child classes do not use 
                            the entry argument beside <strong>ev</strong>. They just raise the damage on the stack. 
                            This is a <strong>public boolean</strong>, so it must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            If it returns <strong>true</strong>, the event will continue and the entity will be hit. 
                            However if it returns <strong>false</strong> then the event will be cancelled and the entity will not be hit. 
                            <strong>stack</strong> is the current item stack that is hitting the entity. 
                            <strong>target</strong> is the <strong>EntityLivingBase</strong> that is hitting the entity. 
                            <strong>attacker</strong> is the <strong>EntityLivingBase</strong> that is attacking the entity.</h6>
                        <li class="items"><code>hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker)
{
    target.setFire(15); //Sets target on fire for 15 seconds
    return true;
}</code></pre>
			<hr>
                        <br><br><h6><strong>initCapabilities</strong> 
                            is called from <strong>ItemStack.setItem</strong>, and will hold extra 
                            data for the life of this ItemStack. This can be retrieved from <strong>stack.getCapabilities()</strong>. 
                            The NBT can be <strong>null</strong> if this is not called from <strong>readNBT</strong> or 
                            if the item stack that it is changing <strong><code>FROM</code></strong> is different 
                            than this item, or the previous item had no capabilities. This is called <code><strong>BEFORE</code></strong> the 
                            stacks item is set so you can use <strong>stack.getItem()</strong> to see 
                            the <code><strong>OLD</code></strong> item. Remember that getItem <code><strong>CAN</code></strong> 
                            return <strong>null</strong>. This method has the identifiers: <strong>public ICapabilityProvider</strong> and 
                            returns a holder instance associated with this ItemStack where you can hold capabilities for
                            the life of this item. <strong>stack</strong> is the item stack. 
                            <strong>nbt</strong> is NBT of this item serialized, or <strong>null</strong>.</h6>
                        <li class="items"><code>initCapabilities(ItemStack stack, NBTTagCompound nbt)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public ICapabilityProvider initCapabilities(ItemStack stack, NBTTagCompound nbt)
{
    return new CapabilityItemHandler();
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isBeaconPayment</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            this Item can be used as a payment to activate the vanilla beacon. 
                            <strong>stack</strong> is the item stack that is/isn't used as a payment.</h6>
                        <li class="items"><code>isBeaconPayment(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isBeaconPayment(ItemStack stack)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isBookEnchantable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> 
                            if the enchantment is allowed. It's use its to allow or forbid the 
                            specific book/item combination as an anvil enchant. 
                            <strong>stack</strong> is the current item stack. 
                            <strong>book</strong> is an item stack of the book.</h6>
                        <li class="items"><code>isBookEnchantable(ItemStack stack, ItemStack book)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isBookEnchantable(ItemStack stack, ItemStack book)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isDamageable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item can be damaged(has durability that can be lost). </h6>
                        <li class="items"><code>isDamageable()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isDamageable()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isDamaged</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item stack has already been damaged(lost durability). 
                            This is only called if <strong>isDamageable()</strong> is <strong>true</strong>. 
                            <strong>stack</strong> is the item stack that can is/is not damaged.</h6>
                        <li class="items"><code>isDamaged(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isDamaged(ItemStack stack)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isEnchantable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item stack can be enchanted. It also checks <strong>isDamagable()</strong> and if 
                            it cannot be stacked. <strong>stack</strong> is the item stack that is/isn't enchantable. </h6>
                        <li class="items"><code>isEnchantable(ItemStack stack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isEnchantable(ItemStack stack)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isFull3D</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item is rendered in full 3D when held.</h6>
                        <li class="items"><code>isFull3D()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isFull3D()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isInCreativeTab</strong> 
                            is a <strong>protected boolean</strong> and returns <strong>true</strong> if 
                            the item is in a creative tab. <strong>targetTab</strong> is the 
                            creative tab in question as it loops through all the creative tabs 
                            and checks if it is in one.</h6>
                        <li class="items"><code>isInCreativeTab(CreativeTabs targetTab)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isInCreativeTab(CreativeTabs targetTab)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isMap</strong> 
                            is a <strong>public boolean</strong> and returns <strong>false</strong> 
                            unless the item is a sub-class of <strong>ItemMapBase</strong>. 
                            This just tells the client that the player is holding a map.</h6>
                        <li class="items"><code>isMap()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isMap()
{
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isRepairable</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the item is repairable. 
                            This is called by <strong>CraftingManager</strong> to 
                            determine if an item is reparable.</h6>
                        <li class="items"><code>isRepairable()</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isRepairable()
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isShield</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            this item is considered a shield. 
                            <strong>stack</strong> is the item stack that is/isn't a shield. 
                            <strong>entity</strong> is the <strong>EntityLivingBase</strong> that is holding the stack.</h6>
                        <li class="items"><code>isShield(ItemStack stack, EntityLivingBase entity)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isShield(ItemStack stack, EntityLivingBase entity)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>isValidArmor</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the given <strong>ItemStack</strong> can 
                            be inserted in an armor slot. This determines if the specific ItemStack 
                            can be placed in the specified armor slot, for the entity. 
                            <strong>stack</strong> is the item stack. 
                            <strong>armorType</strong> is the armor slot to be verified. 
                            <strong>entity</strong> is the entity trying to equip the armor. 
                            Note that in 1.13 this changes to <strong>canEquip()</strong>.</h6>
                        <li class="items"><code>isValidArmor(ItemStack stack, EntityEquipmentSlot armorType, Entity entity)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean isValidArmor(ItemStack stack, EntityEquipmentSlot armorType, Entity entity)
{
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>itemInteractionForEntity</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the item can be used on the 
                            given entity, e.g. shears on sheep. <strong>stack</strong> is the 
                            item stack to check for interactions with entities. 
                            <strong>playerIn</strong> is the player that is trying to do the interaction. 
                            <strong>target</strong> is the entity that the interaction is trying to be done on. 
                            <strong>hand</strong> is the <strong>EnumHand</strong> that the stack is in.</h6>
                        <li class="items"><code>itemInteractionForEntity(ItemStack stack, EntityPlayer playerIn, EntityLivingBase target, EnumHand hand)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean itemInteractionForEntity(ItemStack stack, EntityPlayer playerIn, EntityLivingBase target, EnumHand hand)
{
    if(target instanceof EntityBat)
    {
	return true;
    }
    return false;
}</code></pre>
			<hr>
                        <br><br><h6><strong>onArmorTick</strong> 
                            can be overridden to tick armor in the armor slot. It is a <strong>public void</strong>, so you cannot return a value inside of it. 
                            <strong>world</strong> is the world object that the armor is trying to tick in. 
                            <strong>player</strong> is the player that is wearing the ticking armor. 
                            <strong>itemStack</strong> is the current item stack.</h6>
                        <li class="items"><code>onArmorTick(World world, EntityPlayer player, ItemStack itemStack)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public void onArmorTick(World world, EntityPlayer player, ItemStack itemStack)
{
    player.moveEntityWithHeading(player.moveStrafing, player.moveForward * 1.5);
    super.onArmorTick(world, player, itemStack);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onBlockDestroyed</strong> 
                            is called when a Block is destroyed using this Item. Because it is a <strong>public boolean</strong>, you can return 
                            true to trigger the <strong>"Use Item"</strong> statistic. 
                            <strong>stack</strong> is the item stack that destroyed the block. 
                            <strong>worldIn</strong> is the world object that the block was broken in. 
                            <strong>state</strong> is the state of the block before it was destroyed. 
                            <strong>pos</strong> is the position of the block. 
                            <strong>entityLiving</strong> is the entity that destroyed the block.</h6>
                        <li class="items"><code>onBlockDestroyed(ItemStack stack, World worldIn, IBlockState state, BlockPos pos, EntityLivingBase entityLiving)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean onBlockDestroyed(ItemStack stack, World worldIn, IBlockState state, BlockPos pos, EntityLivingBase entityLiving)
{
    if(worldIn.getBlockState(pos).getBlock().equals(Blocks.MELON))
    {
	for(int i = 0; i < 10; i++)
	{
    	    worldIn.spawnEntity(new EntityPig(world));
	}
    }
    return super.onBlockDestroyed(stack, worldIn, state, pos, entityLiving);
}</code></pre>
			<hr>
                        <br><br><h6><strong>onBlockStartBreak</strong> 
                            is called before a block is broken. Because it is a <strong>public boolean</strong>, you can <strong>return true</strong> to prevent default block harvesting. 
                            Note: In SMP, this is called on both client and server sides! If you <strong>return false</strong> then it will continue as normal and break the block. 
                            <strong>itemStack</strong> is the item stack that is breaking the block. 
                            <strong>pos</strong> is the position of the block that is being broken. 
                            <strong>player</strong> is the player that is breaking the block.</h6>
                        <li class="items"><code>onBlockStartBreak(ItemStack itemstack, BlockPos pos, EntityPlayer player)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean onBlockDestroyed(ItemStack stack, World worldIn, IBlockState state, BlockPos pos, EntityLivingBase entityLiving)
{
    if(worldIn.getBlockState(pos).getBlock().equals(Blocks.MELON))
    {
        worldIn.addWeatherEffect(new EntityLightningBolt(world, pos.getX(), pos.getY(), pos.getZ(), false));
    }
    return super.onBlockDestroyed(stack, worldIn, state, pos, entityLiving);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onCreated</strong> 
                            is called when item is crafted/smelted. This is only used by maps so far. It is a <strong>public void</strong>, so you 
                            cannot return a value. 
                            <strong>stack</strong> is the item stack that was created. 
                            <strong>worldIn</strong> is the world object that the item stack was created in. 
                            <strong>playerIn</strong> was the player that created the item.</h6>
                        <li class="items"><code>onCreated(ItemStack stack, World worldIn, EntityPlayer playerIn)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public void onCreated(ItemStack stack, World worldIn, EntityPlayer playerIn)
{
    stack.addEnchantment(Enchantments.AQUA_AFFINITY, 10);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onDroppedByPlayer</strong> 
                            is called when a player drops the item into the world, It is a <strong>public boolean</strong>, so returning <strong>false</strong> 
                            from this will prevent the item from being removed from the players inventory and spawning in the world. 
                            Whereas returning <strong></strong> will continue to remove the item from the player's inventory and drop it on the ground. 
                            <strong>item</strong> is the item stack before the item is removed from the player. 
                            <strong></strong> is the player that dropped the item.</h6>
                        <li class="items"><code>onDroppedByPlayer(ItemStack item, EntityPlayer player)</code></li>
			<br><strong>Example:</strong>
			<pre><code>@Override
public boolean onDroppedByPlayer(ItemStack item, EntityPlayer player)
{
    player.dropItem(new ItemStack(Items.BLAZE_ROD, 2), false); //Drops a blaze rod instead of dropping the normal item
    return false;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onEntityItemUpdate</strong> 
                            is called by the default implementation of <strong>EntityItem</strong>'s <strong>onUpdate</strong> method, allowing for cleaner control 
                            over the update of the item without having to write a subclass. It is a <strong>public boolean</strong>, so returning <strong>true</strong> 
                            will skip any further update code, and <strong>false</strong> will continue it. 
                            <strong>entityItem</strong> is the item as an entity.</h6>
                        <li class="items"><code>onEntityItemUpdate(EntityItem entityItem)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean onEntityItemUpdate(EntityItem entityItem)
{
    if(entityItem.isInWater())
    {
        entityItem.getEntityWorld().addWeatherEffect(new EntityLightningBolt(entityItem.getEntityWorld(), entityItem.posX, entityItem.posY, entityItem.posZ, false));
    }
    return super.onEntityItemUpdate(entityItem);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onEntitySwing</strong> 
                            is called when an entity tries to play the 'swing' animation with this item stack. It is a <strong>public boolean</strong>, so 
                            returning <strong>true</strong> will cancel any further processing by <strong>EntityLiving</strong>, and returning <strong>false</strong> will continue it. 
                            <strong>entityLiving</strong> is the entity that is playing the 'swing' animation with this item stack. 
                            <strong>stack</strong> is the item stack that is being 'swung'.</h6>
                        <li class="items"><code>onEntitySwing(EntityLivingBase entityLiving, ItemStack stack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean onEntitySwing(EntityLivingBase entityLiving, ItemStack stack)
{
    entityLiving.hitByEntity(entityLiving);
    return super.onEntitySwing(entityLiving, stack);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onHorseArmorTick</strong> 
                            is called every tick from <strong>EntityHorse#onUpdate()</strong> on the item in the armor slot. 
                            Because it is <strong>public void</strong> you cannot return any value inside of it. 
                            <strong>world</strong> is the world object that the horse is in. 
                            <strong>horse</strong> is the horse wearing this armor. 
                            <strong>armor</strong> is the armor itemstack.</h6>
                        <li class="items"><code>onHorseArmorTick(World world, EntityLiving horse, ItemStack armor)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public void onHorseArmorTick(World world, EntityLiving horse, ItemStack armor)
{
    horse.moveEntityWithHeading(horse.moveStrafing, horse.moveForward * 1.5);
    super.onArmorTick(world, horse, armor);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onItemRightClick</strong> 
                            is called when the equipped item is right clicked. It is a <strong>public ActionResult&lt;ItemStack&gt;</strong> and must return an action result 
                            which is usually just <strong>super.onItemRightClick(worldIn, playerIn, handIn)</strong>. 
                            <strong>worldIn</strong> is the world object that the item was clicked in. 
                            <strong>playerIn</strong> is the player that clicked with the item. 
                            <strong>handIn</strong> is the hand that the item was clicked from(mainhand or offhand).</h6>
                        <li class="items"><code>onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public ActionResult&lt;ItemStack&gt; onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)
{
    playerIn.getHeldItem(handIn).shrink(1);
    playerIn.addPotionEffect(new PotionEffect(MobEffects.ABSORPTION, 2500, 10, false, false));
    playerIn.jump();
    return super.onItemRightClick(worldIn, playerIn, handIn);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onItemUse</strong> 
                            is called when a Block is right-clicked with this Item. It is a <strong>public EnumActionResult</strong> and therefore must 
                            return an <strong>EnumActionResult</strong> such as <strong>EnumActionResult.SUCCESS</strong>. 
                            <strong>player</strong> is the player that clicked the block with this item. 
                            <strong>worldIn</strong> is the world object that the block was clicked in. 
                            <strong>pos</strong> is the position of the block that was clicked. 
                            <strong></strong> is the hand that the item was clicked from(mainhand or offhand). 
                            <strong>facing</strong> is the direction that the block clicked is facing. 
                            <strong>hitX</strong> is the X position that the block was clicked. 
                            <strong>hitY</strong> is the Y position that the block was clicked. 
                            <strong>hitZ</strong> is the Z position that the block was clicked.</h6>
                        <li class="items"><code>onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public EnumActionResult onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
{
    worldIn.setBlockState(pos, Blocks.COBBLESTONE.getDefaultState());
    worldIn.spawnParticle(EnumParticleTypes.SMOKE_LARGE, pos.getX()+hitX, pos.getY()+hitY, pos.getZ()+hitZ, 0.0D, 0.0D, 0.0D);
    worldIn.playSound(player, pos, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.AMBIENT, 1.0f, 1.0f);
    player.getHeldItem(hand).attemptDamageItem(1, itemRand, (EntityPlayerMP)player);
    return super.onItemUse(player, worldIn, pos, hand, facing, hitX, hitY, hitZ);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onItemUseFinish</strong> 
                            is called when the player finishes using this Item (e.g. finishes eating.). Not called when the player stops using the Item 
                            before the action is complete. It is a <strong>public ItemStack</strong> so it must return an <strong>ItemStack</strong>. 
                            <strong>stack</strong> is the item stack that is being used. 
                            <strong>worldIn</strong> is the world object that the item is being used in. 
                            <strong>entityLiving</strong> is the entity that is using the item(usually a player).</h6>
                        <li class="items"><code>onItemUseFinish(ItemStack stack, World worldIn, EntityLivingBase entityLiving)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public ItemStack onItemUseFinish(ItemStack stack, World worldIn, EntityLivingBase entityLiving)
{
    worldIn.spawnEntity(new EntityZombie(worldIn));
    return super.onItemUseFinish(stack, worldIn, entityLiving);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onItemUseFirst</strong> 
                            is called when the item is used, before the block is activated. It is a <strong>public EnumActionResult</strong> and therefore must 
                            return an <strong>EnumActionResult</strong> such as <strong>EnumActionResult.SUCCESS</strong>. 
                            <strong>player</strong> is the player that clicked the block with this item. 
                            <strong>worldIn</strong> is the world object that the block was clicked in. 
                            <strong>pos</strong> is the position of the block that was clicked. 
                            <strong>facing</strong> is the direction that the block clicked is facing. 
                            <strong>hitX</strong> is the X position that the block was clicked. 
                            <strong>hitY</strong> is the Y position that the block was clicked. 
                            <strong>hitZ</strong> is the Z position that the block was clicked. 
                            <strong>hand</strong> is the hand that the item was clicked from(mainhand or offhand). </h6>
                        <li class="items"><code>onItemUseFirst(EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, EnumHand hand)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public ItemStack onItemUseFirst(EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, EnumHand hand)
{
    worldIn.spawnEntity(new EntityZombie(worldIn));
    return super.onItemUseFinish(player, world, pos, side, hitX, hitY, itZ, hand);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onLeftClickEntity</strong> 
                            is called when the player Left Clicks (attacks) an entity. Processed before damage is done. It is a 
                            <strong>public boolean</strong>, so if the return value is <strong>true</strong> further processing is canceled and the entity is not attacked. 
                            <strong>stack</strong> is the item stack that the entity was left clicked with. 
                            <strong>player</strong> is the player that left clicked the entity. 
                            <strong>entity</strong> is the entity that was clicked.</h6>
                        <li class="items"><code>onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity)
{
    entity.changeDimension(1);
    return true;
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onPlayerStoppedUsing</strong> 
                            is called when the player stops using an Item (stops holding the right mouse button). It is a <strong>public void</strong>, 
                            so you cannot return a value. <strong>stack</strong> is the item stack that the player stopped using. 
                            <strong>worldIn</strong> is the world object that the player used the item in. 
                            <strong>entityLiving</strong> is the entity that used the item. 
                            <strong>timeLeft</strong> is the time in seconds until the item has stopped being used. </h6>
                        <li class="items"><code>onPlayerStoppedUsing(ItemStack stack, World worldIn, EntityLivingBase entityLiving, int timeLeft)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public void onPlayerStoppedUsing(ItemStack stack, World worldIn, EntityLivingBase entityLiving, int timeLeft)
{
    stack.grow(2); //Increase amount in stack by 2
    super.onPlayerUsing(stack, worldIn, entityLiving, timeLeft);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onUpdate</strong> 
                            is called each tick as long the item is in a player inventory. Used by maps to check if is on a player hand and update it's contents. 
                            It is a <strong>public void</strong>, so you cannot return a value. 
                            <strong>stack</strong> is the current item stack. 
                            <strong>worldIn</strong> is the world object that the item is ticking in. 
                            <strong>entityIn</strong> is the entity which has the item in its inventory. 
                            <strong>itemSlot</strong> is the int value for the slot. 
                            <strong>isSelected</strong> is whether the item is in the player's hot-bar and is selected.</h6>
                        <li class="items"><code>onUpdate(ItemStack stack, World worldIn, Entity entityIn, int itemSlot, boolean isSelected)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public void onUpdate(ItemStack stack, World worldIn, Entity entityIn, int itemSlot, boolean isSelected)
{
    if(!worldIn.isRemote)
    {
        entityIn.performHurtAnimation(); //Acts as if the entity is being hurt but no damage is taken
    }
    super.onUpdate(stack, worldIn, entityIn, itemSlot, isSelected);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>onUsingTick</strong> 
                            is called each tick while using the item. It is a <strong>public void</strong>, so you cannot return a value. 
                            <strong>stack</strong> is the current item stack. 
                            <strong>player</strong> is the entity that is using the item, which is usually a player. 
                            <strong>count</strong> is the amount of time in ticks that the item has been used for continuously.</h6>
                        <li class="items"><code>onUsingTick(ItemStack stack, EntityLivingBase player, int count)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public void onUsingTick(ItemStack stack, EntityLivingBase player, int count)
{
    if(count &lt; 4)
    {
        stack.setItemDamage(0);
    }
    player.addPotionEffect(new PotionEffect(MobEffects.REGENERATION, 20, 1, false, false));
    super.onUsingTick(stack, player, count);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>rayTrace</strong> 
                            makes a <strong>RayTrace</strong> and returns it as a <strong>RayTraceResult</strong>, as it is a <strong>protected RayTraceResult</strong>. 
                            <strong>worldIn</strong> is the world object that it is ray tracing in. 
                            <strong>playerIn</strong> is the player that it is creating the raytrace from. 
                            <strong>useLiquids</strong> is whether or not it will count liquids as the end of the trace.</h6>
                        <li class="items"><code>rayTrace(World worldIn, EntityPlayer playerIn, boolean useLiquids)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
protected RayTraceResult rayTrace(World worldIn, EntityPlayer playerIn, boolean useLiquids)
{
    playerIn.jump();
    playerIn.performHurtAnimation();
    playerIn.capabilities.setPlayerWalkSpeed(playerIn.getAIMoveSpeed()/2);
    return super.rayTrace(worldIn, playerIn, useLiquids);
}</code></pre>
                        <hr>
                        <br><br><h6><strong>readNBTShareTag</strong> 
                            decides what to do with the NBT data received from <strong>getNBTShareTag()</strong>. It is a <strong>public void</strong>, so you cannot return a value. 
                            </strong>stack</strong> is the stack that received NBT. 
                            <strong>nbt</strong> is received NBT, and can be <strong>null</strong>.</h6>
                        <li class="items"><code>readNBTShareTag(ItemStack stack, NBTTagCompound nbt)</code></li>
                        <br><strong>Example:</strong>
			            <pre><code>@Override
public void readNBTShareTag(ItemStack stack, NBTTagCompound nbt)
{
    //This is assuming that your item has food and saturation set up to be stored in nbt
    super.readNBTShareTag(stack, nbt);
    this.food = nbt.getInteger("food");
    this.saturation = nbt.getFloat("saturation");
}</code></pre>
                        <hr>
                    </ul>
                </h6>
            </section>
            <footer>
                Test
            </footer>
    </body>
</html>