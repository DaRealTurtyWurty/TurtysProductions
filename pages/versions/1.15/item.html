<!DOCTYPE html>
<html lang="en">
    <head>
        <title>1.15.2 Item.java</title>
        <link rel="stylesheet" href="../../../stylesheets/dictionaryStyle.css">
    </head>
    <body>
        <nav>
            <ul>
                <li class="active"><a href="../../moddingdictionary.html" class="aactive">Modding Version Dictionaries</a></li>
                <li class="active"><a href="../../minecraftmods.html" class="inactive">My Minecraft Mods</a></li>
                <li class="active"><a href="../../../index.html" class="inactive">Home</a></li>
            </ul>
            <h1>Turty's Productions</h1>
        </nav>
        <form>
            <div>
                <button onclick="search()" id="searchButton" type='button'>Search</button>
                <script>
                    function search() {
                        var text = document.getElementById("name").value;
                        var elements = Array.from(document.getElementsByClassName("items"));
                        var correctCriteriaElements = [];
                        elements.forEach(element => {
                            if((text.split("(")[0] != null && text.split("(")[0] != "undefined" && text.split("(")[0] != "") && (element.textContent.includes(text.split("(")[0]))) {
                                console.log(element.textContent.split("(")[0])
                                correctCriteriaElements.push(element);
                            }
                        });
                        correctCriteriaElements[0].scrollIntoView();
                    }
                </script>

                <input type="search" id="name" name="name" required minlength="0" maxlength="30" size="30" placeholder="Search for methodName">
            </div>
        </form>
        <section>
                <p class="headingPara">Item.java methods and variables</p>
                <h6>
                    <ul>
                        <br><br><h6><strong>addInformation</strong> is a <strong>public void</strong> so it does not return anything, 
                            it is used for adding a tooltip to the item(a short description). 
                            <strong>stack</strong> is the itemstack to add the tooltip to. 
                            <strong>worldIn</strong> is the world that the stack is in. 
                            <strong>tooltip</strong> allows you to then add a tooltip 
                            using <strong>tooltip.add()</strong>. Finally 
                            <strong>flagIn</strong> can be used to declare 
                            whether it is an <code><strong>ADVANCED</strong></code> 
                            tooltip or a <strong><code>NORMAL</strong></code> tooltip.</h6>
                        <li class="items"><code>addInformation(ItemStackStack stack, World worldIn, List&lt;String&gt; tooltip, ITooltipFlag flagIn)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn)
{
    if(KeyboardHelper.isHoldingShift())
	{
		tooltip.add(new StringTextComponent("Test Information"));
	} else {
		tooltip.add(new StringTextComponent("Hold" + "\u00A7e" + " Shift " + "\u00A77" + "for more information!"));
	}
	super.addInformation(stack, worldIn, tooltip, flagIn);
}</code></pre>
                        <hr></h6>

                        <br><br><h6><strong>asItem</strong> is a <strong>public Item</strong>. This returns the original <strong>Item</strong> 
                            from <strong>net.minecraft.item.Item</strong>.</h6>
                        <li class="items"><code>asItem()</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public Item asItem() {
    return this;
}</code></pre>
                    <hr></h6>

                    <br><br><h6><strong>canApplyAtEnchantingTable</strong> is a <strong>public boolean</strong>.
                        Checks whether an item can be enchanted with a certain enchantment. This applies specifically to enchanting an item in the enchanting table and is called 
                        when retrieving the list of possible enchantments for an item. Enchantments may additionally (or exclusively) be doing their own 
                        checks in <strong>net.minecraft.enchantment.Enchantment.canApplyAtEnchantingTable(ItemStack);</strong>. Check the individual implementation for reference. 
                        By default this will check if the enchantment type is valid for this item type.
                        <strong>stack</strong> is the item that is being enchanted.
                        <strong>enchantment</strong> is the enchantment to be applied to the item.</h6>
                        <li class="items"><code>canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment)
{
    if(enchantment.isAllowedOnBooks() && stack.hasEffect()) 
    {
        return true;
    }
    return false;
}</code></pre>
                    <hr></h6>

                    <br><br><h6><strong>canContinueUsing</strong> is a <strong>public boolean</strong>.
                        This is called whilst an item is in 'active' use to determine if usage should continue. This allows items to continue being used while sustaining damage, 
                        for example.
                        <strong>oldStack</strong> is the previous 'active' stack.
                        <strong>newStack</strong> is the stack currently in the active hand.
                        <li class="items"><code>canContinueUsing(ItemStack oldStack, ItemStack newStack)</code></li>
                        <br><strong>Example:</strong>
                        <pre><code>@Override
public boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) 
{
	if(oldStack.hasDisplayName()) 
	{
		return true;
	}
	return false;
}</code></pre>
                <hr></h6>

                <br><br><h6><strong>canDisableShield</strong> is a <strong>public boolean</strong>.
                    This is whether the item can/cannot disable a shield.
                    <strong>stack</strong> is the item that can/cannot disable the shield.
                    <strong>shield</strong> is the item stack that corresponds with the shield.
                    <strong>entity</strong> is the living entity holding the shield.
                    </strong>attacker</strong> is the living entity holding the item.
                    <li class="items"><code>canDisableShield(ItemStack stack, ItemStack shield, LivingEntity entity, LivingEntity attacker)</code></li>
                    <br><strong>Example:</strong>
                    <pre><code>@Override
public boolean canDisableShield(ItemStack stack, ItemStack shield, LivingEntity entity, LivingEntity attacker) 
{
    if(EnchantmentHelper.hasBindingCurse(shield))
    {
        return true;
    }
    return false;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>canEquip</strong> is a <strong>public boolean</strong>.
                This method determines if the specific ItemStack can be placed in the specified armor slot, for the entity.
                <strong>stack</strong> is the armor piece.
                <strong>armorType</strong> is the slot that it can/cannot be placed in.
                <strong>entity</strong> is the entity that can/cannot wear the armor piece.
                <li class="items"><code>canEquip(ItemStack stack, EquipmentSlotType armorType, Entity entity)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public boolean canEquip(ItemStack stack, EquipmentSlotType armorType, Entity entity) 
{
    if(armorType == EquipmentSlotType.LEGS && entity instanceof ZombieEntity && stack.hasEffect())
    {
        return true;
    }
    return false;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>canHarvestBlock</strong> is a <strong>public boolean</strong>.
                This method checks whether this item can harvest the given block.
                <strong>blockIn</strong> is the current block state of the block.
                <li class="items"><code>canHarvestBlock(BlockState blockIn)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public boolean canHarvestBlock(BlockState blockIn)
{
    if(blockIn.getBlock().canSpawnInBlock()) return true;
    else return false;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>canHarvestBlock</strong> is a <strong>public boolean</strong>.
                This method is the ItemStack sensitive version of <strong>canHarvestBlock(BlockState blockIn)</strong> and checks whether this item 
                stack can harvest the given block.
                <strong>state</strong> is the current block state of the block.
                <strong>stack</strong> is the current item stack of the item.
                <li class="items"><code>canHarvestBlock(ItemStack stack, BlockState state)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public boolean canHarvestBlock(ItemStack stack, BlockState state)
{
    if(blockIn.getBlock().canSpawnInBlock() && stack.isDamaged()) return true;
    else return false;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>canPlayerBreakBlockWhileHolding</strong> is a <strong>public boolean</strong>.
                This method checks whether the player can break the given block whilst holding this item. Return true will allow this item to break the block,
                returning false will disable this player from breaking the block.
                <strong>state</strong> is the current state of the block.
                <strong>worldIn</strong> is the current instance of the world in which the block is in.
                <strong>pos</strong> is the position of the block.
                <strong>player</strong> is the player entity that is trying to break the block.
                <li class="items"><code>canPlayerBreakBlockWhileHolding(BlockState state, World worldIn, BlockPos pos, PlayerEntity player)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public boolean canPlayerBreakBlockWhileHolding(BlockState state, World worldIn, BlockPos pos, PlayerEntity player)
{
    if(player.onGround && player.hasReducedDebug() && state.getBlock() != Blocks.ACACIA_BUTTON) return true;
    else {
        if(worldIn.getBiome(pos) == Biomes.COLD_OCEAN) return true;
        else return false;
    }
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>createEntity</strong> is a <strong>public Entity</strong>.
                This function should return a new entity to replace the dropped item.
                Returning <strong>null</strong> here will not kill the <strong>EntityItem</strong> and will just leave it to function normally. 
                This is called when the item it placed in a world.
                <strong>world</strong> is the world object.
                <strong>location</strong> is the EntityItem object, and is useful for getting the position of the entity.
                <strong>itemstack</strong> is the current item stack.
                <li class="items"><code>createEntity(World world, Entity location, ItemStack itemstack)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public Entity createEntity(World world, Entity location, ItemStack itemstack)
{
    if (itemstack.isOnItemFrame()) {
        if (itemstack.getItemFrame().shouldRiderSit()) {
            PigEntity pig = new PigEntity(EntityType.PIG, world);
            pig.setPosition(location.getPosX(), location.getPosY(), location.getPosZ());
            return pig;
        } else {
            return null;
        }
    } else {
        CreeperEntity creeper = new CreeperEntity(EntityType.CREEPER, world);
        creeper.setPosition(location.getPosX(), location.getPosY(), location.getPosZ());
        creeper.setCreeperState(1);
        creeper.serializeNBT().putByte("ExplosionRadius", (byte) 200);
        return creeper;
    }
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>damageItem</strong> is a <strong>public &lt;T extends LivingEntity&gt; int</strong>.
                This function is used to reduce the durability of this item by the amount given.
                This can be used to e.g. consume power from NBT before durability.
                <strong>stack</strong> is the item stack to be damaged.
                <strong>amount</strong> is the amount to damage the stack by.
                <strong>entity</strong> is the living entity which has the stack.
                <strong>onBroken</strong> is the consumer for what should happen when the item breaks.
                <li class="items"><code>damageItem(ItemStack stack, int amount, T entity, Consumer<T> onBroken)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public &lt;T extends LivingEntity&gt; int damageItem(ItemStack stack, int amount, T entity, Consumer&lt;T&gt; onBroken)
{
    entity.setFire(5);
    BlockPos pos = new BlockPos(entity.getPosX()+random.nextInt(25) - 10, entity.getPosY()+random.nextInt(25) - 10, entity.getPosZ()+random.nextInt(25) - 10);
    entity.setPosition(pos.getX(), pos.getY(), pos.getZ());
    entity.world.setBlockState(pos, Blocks.AIR.getDefaultState());
    return 2;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>doesSneakBypassUse</strong> is a <strong>public boolean</strong>.
                This function is used to determine whether this item, when held, allows sneak-clicks to pass through to the underlying block.
                <strong>stack</strong> is the item stack in question.
                <strong>world</strong> is the world object.
                <strong>pos</strong> is the position of the block in the world.
                <strong>player</strong> is the player that is holding the item.
                <li class="items"><code>doesSneakBypassUse(ItemStack stack, IWorldReader world, BlockPos pos, PlayerEntity player)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public boolean doesSneakBypassUse(ItemStack stack, IWorldReader world, BlockPos pos, PlayerEntity player)
{
    if(world.getBlockState(pos).getBlock() == Blocks.BEDROCK) return true;
    else {
        if(player.isCreative()) return true;
        else return false;
    }
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>fillItemGroup</strong> is a <strong>public void</strong>.
                This function is used to put items with the same id (i.e. potions, enchanted books) in the same item group.
                <strong>group</strong> is the ItemGroup to check against, for example to see if the items are already in there.
                <strong>items</strong> is the list of items in the ItemGroup.
                <li class="items"><code>fillItemGroup(ItemGroup group, NonNullList&lt;ItemStack&gt; items)</code></li>
                <br><strong>Example from PotionItem.java:</strong>
                <pre><code>@Override
public void fillItemGroup(ItemGroup group, NonNullList&lt;ItemStack&gt; items)
{
    if (this.isInGroup(group)) {
        for (Potion potion : Registry.POTION) {
            if (potion != Potions.EMPTY) {
                items.add(PotionUtils.addPotionToItemStack(new ItemStack(this), potion));
            }
        }
    }
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>func_219972_a</strong> is a <strong>public void</strong>.
                This function is used to purely just to load the crossbow. In the future this may be renamed to <strong>loadCrossbow</strong> or <strong>chargeCrossbow</strong>.
                <strong>worldIn</strong> is the world object.
                <strong>livingEntityIn</strong> is the living entity holding the crossbow.
                <strong>stack</strong> is the crossbow item stack.
                <strong>count</strong> is the amount of available arrows.
                <li class="items"><code>func_219972_a(World worldIn, LivingEntity livingEntityIn, ItemStack stack, int count)</code></li>
                <br><strong>Example from CrossbowItem.java:</strong>
                <pre><code>@Override
public void func_219972_a(World worldIn, LivingEntity livingEntityIn, ItemStack stack, int count)
{
    if (!worldIn.isRemote) {
        int i = EnchantmentHelper.getEnchantmentLevel(Enchantments.QUICK_CHARGE, stack);
        SoundEvent soundevent = this.getSoundEvent(i);
        SoundEvent soundevent1 = i == 0 ? SoundEvents.ITEM_CROSSBOW_LOADING_MIDDLE : null;
        float f = (float)(stack.getUseDuration() - count) / (float)getChargeTime(stack);
        if (f &lt; 0.2F) {
           this.isLoadingStart = false;
           this.isLoadingMiddle = false;
        }

        if (f &gt;= 0.2F && !this.isLoadingStart) {
           this.isLoadingStart = true;
           worldIn.playSound((PlayerEntity)null, livingEntityIn.getPosX(), livingEntityIn.getPosY(), livingEntityIn.getPosZ(), soundevent, SoundCategory.PLAYERS, 0.5F, 1.0F);
        }

        if (f &gt;= 0.5F && soundevent1 != null && !this.isLoadingMiddle) {
           this.isLoadingMiddle = true;
           worldIn.playSound((PlayerEntity)null, livingEntityIn.getPosX(), livingEntityIn.getPosY(), livingEntityIn.getPosZ(), soundevent1, SoundCategory.PLAYERS, 0.5F, 1.0F);
        }
     }
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>func_225519_S__</strong> is a <strong>public SoundEvent</strong>.
                This function is used to get the eat sound. In future mappings this could be renamed to <strong>getEatingSound</strong> or <strong>getEatSound</strong>.
                <li class="items"><code>func_225519_S__()</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public SoundEvent func_225519_S__()
{
    return SoundEvents.ENTITY_GENERIC_EAT;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>func_225519_U__</strong> is a <strong>public SoundEvent</strong>.
                This function is used to get the drink sound. In future mappings this could be renamed to <strong>getDrinkingSound</strong> or <strong>getDrinkSound</strong>.
                <li class="items"><code>func_225519_S__()</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public SoundEvent func_225519_S__()
{
    return SoundEvents.ENTITY_GENERIC_DRINK;
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>getAnimationParameters</strong> is a <strong>public ImmutableMap&lt;String, ITimeValue&gt;</strong>.
                This function is a bit complex. All 3 parameters are <strong>final</strong> as <strong>ImmutableMap</strong>s can only have 
                contents that will never change. 
                <strong>stack</strong> is the current itemstack. 
                <strong>world</strong> is the world object. 
                <strong>entity</strong> is the <strong>EntityLivingBase</strong> that this animation is affecting. 
                It is used to retrieve parameters to an item animation mechanism which is known as animation state machine or ASM(not to be confused with the Advanced System Manager). 
                You can read about this in the Forge Docs <a href="https://mcforge.readthedocs.io/en/latest/animation/intro/" class="hyperlink"><strong>here</strong></a> 
                as it does get very complex! It is mostly unused in forge, so it is unlikely for the common user to ever need it, but it is there just in case.
                <li class="items"><code>getAnimationParameters(ItemStack stack, World world, LivingEntity entity)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public ImmutableMap&lt;String, ITimeValue&gt; getAnimationParameters(ItemStack stack, World world, LivingEntity entity)
{
    return stack.getItem().getAnimationParameters(stack, world, entity);
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>getArmorModel</strong> is a <strong>public &lt;A extends BipedModel&lt;?&gt;&gt; A</strong>.
                You can override this method to have an item handle its own armor rendering. So instead of using the normal armor
                model, you can instead use a <strong>BipedModel</strong>. This essentially allows for custom model armor.
                <strong>entityLiving</strong> is the living entity that is wearing the armor. 
                <strong>itemStack</strong> is the armor item stack to render the model for. 
                <strong>armorSlot</strong> is the slot to render the armor in. 
                <strong>_default</strong> is the original armor model - this has attributes set.
                <li class="items"><code>getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlotType armorSlot, A _default)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public &lt;A extends BipedModel&lt;?&gt;&gt; A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlotType armorSlot, A _default)
{
    return new BipedWizardHatModel(0.5f); //This is just a made up class that extends BipedModel
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>getArmorTexture</strong> is a <strong>public String</strong>.
                This is called by RenderBiped and RenderPlayer to determine the armor texture that should be use for the currently equipped item. 
                This will only be called on instances of ArmorItem. Returning null from this function will use the default value.
                <strong>stack</strong> is the armor item to get the texture for. 
                <strong>entity</strong> is the entity to render the armor texture on to. 
                <strong>slot</strong> is the slot that the armor is in. 
                <strong>type</strong> is the subtype, can be null or "overlay".
                <li class="items"><code>getArmorTexture(ItemStack stack, Entity entity, EquipmentSlotType slot, String type)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlotType slot, String type)
{
    return "modid:textures/models/armor/example_armor";
}</code></pre>
            <hr></h6>

            <br><br><h6><strong>getArmorTexture</strong> is a <strong>public String</strong>.
                This is called by RenderBiped and RenderPlayer to determine the armor texture that should be use for the currently equipped item. 
                This will only be called on instances of ArmorItem. Returning null from this function will use the default value.
                <strong>stack</strong> is the armor item to get the texture for. 
                <strong>entity</strong> is the entity to render the armor texture on to. 
                <strong>slot</strong> is the slot that the armor is in. 
                <strong>type</strong> is the subtype, can be null or "overlay".
                <li class="items"><code>getArmorTexture(ItemStack stack, Entity entity, EquipmentSlotType slot, String type)</code></li>
                <br><strong>Example:</strong>
                <pre><code>@Override
public String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlotType slot, String type)
{
    return "modid:textures/models/armor/example_armor";
}</code></pre>
            <hr></h6>
            
                    </ul>
                </h6>
            </section>
        <footer>
            Test
        </footer>
    </body>
</html>